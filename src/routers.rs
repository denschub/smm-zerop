mod app_meta;
mod smm2;
mod static_pages;

use axum::{
    Router,
    extract::Request,
    handler::Handler,
    http::{HeaderValue, header::CACHE_CONTROL},
    middleware,
    response::Response,
};
use tower::ServiceBuilder;
use tower_http::services::ServeDir;

use crate::{components::app_state::AppState, errors::ResponseError};

/// Builds the main router.
/// This should collect all the routes from all over the app, and return a
/// full router for use in the app.
/// Nested inside it is a [ServeDir] service that serves all files from the
/// `public/` dir. It's coming *after* all the Axum routes, so any in-app
/// routes take precedence. There are some upsides and downsides to each order,
/// but file system lookups are slower than Axum's routing, so this probably
/// makes sense.
pub fn build_main_router(state: AppState) -> Router {
    let error_handling_layer =
        middleware::from_fn_with_state(state.clone(), ResponseError::handle_error_middleware);

    let fallback_service = ServiceBuilder::new()
        .layer(middleware::from_fn(static_cache_header_middleware))
        .layer(error_handling_layer.clone())
        .service(
            ServeDir::new("public")
                .append_index_html_on_directories(false)
                .precompressed_br()
                .precompressed_zstd()
                .fallback(Handler::with_state(fallback_handler, state.clone())),
        );

    Router::new()
        .merge(app_meta::build())
        .merge(smm2::build())
        .merge(static_pages::build())
        .layer(error_handling_layer)
        .fallback_service(fallback_service)
        .with_state(state)
}

/// Little middleware that sets the Cache-Control header for static files served
/// from the public/ directory.
/// If a Cache header is already set for some reason, it does nothing.
/// if the request was a success (i.e. status code [200-399]) AND the request
/// was for one of the assets inside /assets/, it sets the header to
/// `public, max-age=31536000, immutable` (1 year). In all other cases, it
/// defaults to `public, max-age=86400` (24 hours).
/// The intention here is to tell the client that it can cache /assets/ forever,
/// since all the files in there are generated by Vite and have hashes in their
/// filenames.
pub async fn static_cache_header_middleware(
    req: Request,
    next: middleware::Next,
) -> Result<Response, ResponseError> {
    let is_assets_req = req.uri().path().starts_with("/assets/");
    let mut response = next.run(req).await;

    if !response.headers().contains_key(CACHE_CONTROL) {
        if is_assets_req && (response.status().is_success() || response.status().is_redirection()) {
            response.headers_mut().append(
                CACHE_CONTROL,
                HeaderValue::from_static("public, max-age=31536000, immutable"),
            );
        } else {
            response.headers_mut().append(
                CACHE_CONTROL,
                HeaderValue::from_static("public, max-age=86400"),
            );
        }
    }

    Ok(response)
}

#[axum::debug_handler]
async fn fallback_handler() -> Result<(), ResponseError> {
    Err(ResponseError::NotFoundError())
}
